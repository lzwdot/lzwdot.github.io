import{_ as i,c as e,o as a,aj as t}from"./chunks/framework.Dc3YHBOS.js";const h=JSON.parse('{"title":"设计模式基础","description":"","frontmatter":{"date":"2025-09-14 14:00:12"},"headers":[],"relativePath":"docs/29509.md","filePath":"docs/6.design-pattern/29509.md","lastUpdated":1759844364000}'),o={name:"docs/29509.md"};function p(r,l,u,c,d,n){return a(),e("div",null,[...l[0]||(l[0]=[t('<h1 id="设计模式基础" tabindex="-1">设计模式基础 <a class="header-anchor" href="#设计模式基础" aria-label="Permalink to “设计模式基础”">​</a></h1><h2 id="面向对象编程" tabindex="-1">面向对象编程 <a class="header-anchor" href="#面向对象编程" aria-label="Permalink to “面向对象编程”">​</a></h2><ul><li>OOP - Object Oriented Program</li><li>将抽象的编程概念，想象成一个对象</li></ul><p>重要概念</p><ul><li>类 class，即模板</li><li>对象，即实例</li></ul><p>面向对象三要素</p><ul><li>继承 - 抽离公共代码，实现代码复用；注意 super 的使用</li><li>封装 - 高内聚，低耦合；修饰符 private protected public</li><li>多态 - 更好的扩展性；函数的重写和重载（一个函数多参数类型）</li></ul><h2 id="uml-类图" tabindex="-1">UML 类图 <a class="header-anchor" href="#uml-类图" aria-label="Permalink to “UML 类图”">​</a></h2><blockquote><p>用于面向对象设计的图形化语言</p></blockquote><ul><li>统一建模语言 Unfied Modeling Language</li><li>软件设计的绘图标准</li><li>除了类图，还有其他的图，如时序图、协作图等</li></ul><p>画图工具</p><ul><li>安装 MS Visio</li><li>或其他支持 UML 工具</li></ul><p>单个类</p><ul><li>三个区域：名称，属性，方法</li><li>权限描述：+（public），-（private），#（protected）</li></ul><p>类之间的关系</p><ul><li>实现 - 实现接口；虚线空心箭头 ---》</li><li>泛化 - 继承父类；实线空心箭头 ——》</li><li>关联 - A 类是 B 类的属性；实线实心箭头 ——&gt;</li></ul><p>关联关系的细化</p><blockquote><p>一般不会这么细化</p></blockquote><ul><li>聚合- 整体包含部分，部分可以脱离整体而单独存在；空心菱形（实线实心箭头） ◇——&gt;</li><li>组合- 整体包含部分，部分不可以脱离整体；实心菱形（实线实心箭头） ◆——&gt;</li><li>依赖- 不是属性关系，而是函数参数或返回值；虚线箭头（实心箭头） - - -&gt;</li></ul><h2 id="设计原则" tabindex="-1">设计原则 <a class="header-anchor" href="#设计原则" aria-label="Permalink to “设计原则”">​</a></h2><ul><li>SOLID 五大设计原则</li><li>重点关注：开放-封闭原则</li></ul><p>单一职责原则（SRP）</p><ul><li>每个程序都做好一件事</li><li>功能太多了就要拆分</li><li>每个部分保持相互独立</li></ul><p>开放-封闭原则（OCP）</p><ul><li>对扩展开发</li><li>对修改封闭</li><li>需求发生变化时，通过扩展来解决，而非改动</li></ul><p>里氏替换原则（LSP）</p><blockquote><p>前端不常用</p></blockquote><ul><li>子类能覆盖父类</li><li>父类出现的地方，子类也能出现</li></ul><p>接口隔离原则（ISP）</p><blockquote><p>类似单一职责原则</p></blockquote><ul><li>保持接口的单一独立</li><li>避免出现“胖接口”</li></ul><p>依赖倒置原则（DIP）</p><ul><li>面向接口编程</li><li>而非面向实例</li></ul>',33)])])}const _=i(o,[["render",p]]);export{h as __pageData,_ as default};
