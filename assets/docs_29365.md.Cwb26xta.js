import{_ as l,c as i,o as a,aj as t,aH as r,aF as n}from"./chunks/framework.Dc3YHBOS.js";const h=JSON.parse('{"title":"React 组件渲染和更新的过程","description":"","frontmatter":{"date":"2022-01-28 11:34:57"},"headers":[],"relativePath":"docs/29365.md","filePath":"docs/3.react-use/react-principle/29365.md","lastUpdated":1735962194000}'),o={name:"docs/29365.md"};function c(p,e,d,s,m,_){return a(),i("div",null,[...e[0]||(e[0]=[t('<h1 id="react-组件渲染和更新的过程" tabindex="-1">React 组件渲染和更新的过程 <a class="header-anchor" href="#react-组件渲染和更新的过程" aria-label="Permalink to “React 组件渲染和更新的过程”">​</a></h1><p>问题</p><ul><li>JSX 如何渲染为页面</li><li>setState 之后如何更新页面</li><li>全流程是怎么样</li></ul><h2 id="回顾知识点" tabindex="-1">回顾知识点 <a class="header-anchor" href="#回顾知识点" aria-label="Permalink to “回顾知识点”">​</a></h2><p>Vue 组件渲染和更新过程</p><p><img src="'+r+'" alt="vue" loading="lazy"></p><p>JSX 本质和 vdom</p><ul><li>JSX 即 createElement 函数</li><li>执行会生产 vnode</li><li>patch(elem,vnode) 和 patch(vnode,newVnode)</li></ul><p>回顾 dirtyComponents</p><p><img src="'+n+'" alt="react" loading="lazy"></p><h2 id="渲染和更新过程" tabindex="-1">渲染和更新过程 <a class="header-anchor" href="#渲染和更新过程" aria-label="Permalink to “渲染和更新过程”">​</a></h2><p>渲染过程</p><ul><li>props state</li><li>render() 生成 vnode</li><li>patch(elem,vnode)，可能不叫 patch 名字，但过程一样</li></ul><p>更新过程</p><ul><li>setState(newState) --&gt; dirtyComponents（可能有子组件）</li><li>render() 生成 newVnode</li><li>patch(elem,newVnode)，可能不叫 patch 名字，但过程一样</li></ul><p>更新的两个阶段</p><ul><li>上述的 patch 被拆分为两个阶段：</li><li>reconciliation 阶段 - 执行 diff 算法，纯 JS 计算</li><li>commit 阶段 - 将 diff 结果渲染 DOM</li></ul><p>React fiber</p><ul><li>JS 是单线程，且和 DOM 渲染共用一个</li><li>当组件足够复杂，组件更新时计算和渲染都压力大</li><li>同时再有 DOM 操作需求（动画，鼠标拖拽等），将卡段</li><li><strong>解决方案 fiber</strong><ul><li>将 reconciliation 阶段进行任务拆分（commit 无法拆分）</li><li>DOM 需要渲染时暂停，空闲时恢复</li><li>window.requestIdleCallback （存在兼容性）</li></ul></li></ul><p>关于 fiber</p><ul><li>React 内部运行机制，开发者体会不到</li><li>了解背景和基本概念即可</li></ul>',21)])])}const f=l(o,[["render",c]]);export{h as __pageData,f as default};
